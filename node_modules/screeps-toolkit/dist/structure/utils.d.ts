/// <reference types="screeps" />
/**
 * Typed check for {@link Structure.structureType}
 * @param s ths structure to check
 * @param type structure type constant
 * @returns whether this structure is of type
 */
export declare function isStructureType<T extends keyof ConcreteStructureMap>(s: Structure, type: T): s is ConcreteStructureMap[T];
/**
 * Typed filter for {@link Room.find}
 * @example room.find(FIND_STRUCTURES, { filter: filterStructureType(STRUCTURE_CONTAINER) })
 * @param type structure type constant
 * @returns filter object
 */
export declare function filterStructureType<T extends keyof ConcreteStructureMap>(type: T): (s: Structure) => s is ConcreteStructureMap[T];
export declare class StructuresByType implements Iterable<[StructureConstant, readonly AnyStructure[]]> {
    private map;
    readonly length: number;
    constructor(sts: AnyStructure[]);
    [Symbol.iterator](): IterableIterator<[StructureConstant, AnyStructure[]]>;
    get<T extends StructureConstant>(type: T): ConcreteStructureMap[T][];
}
/**
 * Compute a level comparable with {@link StructureController} level evaluating built structures.
 * @param sbt storage of all structures by type
 * @param requiredStructures structure types needed for a level to be complete
 * @returns an object like {@link GlobalControlLevel}
 */
export declare function getStructuralLevel(sbt: StructuresByType, requiredStructures?: readonly BuildableStructureConstant[]): {
    level: number;
    progress: number;
    progressTotal: number;
};
/**
 * Compute ticks until a {@link StructureRoad} is destroyed by time decay.
 * @param road the road to check
 * @returns ticks until decay
 */
export declare function getRoadTicksToDestroy(road: StructureRoad): number;
