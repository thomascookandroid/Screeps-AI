/**
 * Calls the specified callback function for all the elements in a list.
 * The return value of the callback function is the accumulated result,
 * and is provided as an argument in the next call to the callback function.
 * `ts.reduce` But also works with generators.
 * @param ts list of things
 * @param acc function to accumulate a thing to
 * @param initial accumulator start value
 * @returns the accumulated total
 */
export declare function reduce<T, U = T>(ts: Iterable<T>, acc: (acc: U, t: T) => U, initial: U): U;
/** Data-last version of {@link reduce} */
export declare const reduce_: <T, U = T>(acc: (acc: U, t: T) => U, initial: U) => (t: Iterable<T>) => U;
/**
 * Compute the sum of a list of things.
 * ```ts
 * ts.reduce((acc, t) => acc + map(t), 0)
 * ```
 * But also works with generators.
 * @param ts list of things
 * @param map function to convert a thing to number
 * @returns the total sum
 */
export declare function sum<T>(ts: Iterable<T>, map: (t: T) => number): number;
/** Data-last version of {@link sum} */
export declare const sum_: <T>(p: (t: T) => number) => (t: Iterable<T>) => number;
/**
 * Compute the average of a list of things.
 * ```ts
 * ts.reduce((acc, t) => acc + map(t), 0) / ts.length
 * ```
 * But also works with generators.
 * @param ts list of things
 * @param map function to convert a thing to number
 * @returns the average or 0 if ts is empty
 */
export declare function avg<T>(ts: Iterable<T>, map: (t: T) => number): number;
/** Data-last version of {@link avg} */
export declare const avg_: <T>(p: (t: T) => number) => (t: Iterable<T>) => number;
/**
 * Count values of a list of things also works with generators.
 * @param ts list of things
 * @param pred optional: function to check if thing is valid
 * @returns the number of valid things
 */
export declare function count<T>(ts: Iterable<T>, pred?: (t: T) => boolean): number;
/** Data-last version of {@link count} */
export declare const count_: <T>(p: ((t: T) => boolean) | undefined) => (t: Iterable<T>) => number;
/**
 * Check the value is not undefined
 * @param t value to check
 * @returns is not undefined
 */
export declare function exists<T>(t: T | undefined): t is T;
/**
 * Find the thing of a list with the biggest value also works with generators.
 * @param ts list of things
 * @param map function to convert a thing to number
 * @param minE optional: exclusive minimum value to accept
 * @returns the thing will the biggest value or undefined if none are superior to {@link minE}
 */
export declare function max<T>(ts: Iterable<T>, map: (t: T) => number, minE?: number): T | undefined;
/** Data-last version of {@link max} */
export declare const max_: <T>(map: (t: T) => number, minE?: number | undefined) => (t: Iterable<T>) => T | undefined;
/**
 * Find the thing of a list with the lowest value also works with generators.
 * @param ts list of things
 * @param map function to convert a thing to number
 * @param maxE optional: exclusive maximum value to accept
 * @returns the thing will the lowest value or undefined if none are inferior to {@link maxE}
 */
export declare function min<T>(ts: Iterable<T>, map: (t: T) => number, maxE?: number): T | undefined;
/** Data-last version of {@link min} */
export declare const min_: <T>(map: (t: T) => number, maxE?: number | undefined) => (t: Iterable<T>) => T | undefined;
/**
 * Find the biggest value in a list of things also works with generators.
 * @param ts list of things
 * @param map function to convert a thing to number
 * @param minE optional: exclusive minimum value to accept
 * @returns the biggest value and the associated thing or undefined if none are superior to {@link minE}
 */
export declare function maxEntry<T>(ts: Iterable<T>, map: (t: T) => number, minE?: number): {
    t: T;
    value: number;
} | undefined;
/**
 * Find the lowest value in a list of things also works with generators.
 * @param ts list of things
 * @param map function to convert a thing to number
 * @param maxE optional: exclusive maximum value to accept
 * @returns the lowest value and the associated thing or undefined if none are superior to {@link minE}
 */
export declare function minEntry<T>(ts: Iterable<T>, map: (t: T) => number, maxE?: number): {
    t: T;
    value: number;
} | undefined;
/**
 * Calls a defined callback function on each element of a list.
 * ```ts
 * ts.map(map)
 * ```
 * But also works with generators.
 * @param ts list of things
 * @param map function to convert a thing to something
 * @yields each mapped thing
 */
export declare function map<T, U>(ts: Iterable<T>, map: (t: T) => U): IterableIterator<U>;
/** Data-last version of {@link map} */
export declare const map_: <T, U>(p: (t: T) => U) => (t: Iterable<T>) => IterableIterator<U>;
/**
 * Calls a defined callback function on each element of a list.
 * ```ts
 * ts.forEach(map)
 * ```
 * But also works with generators.
 * @param ts list of things
 * @param act function to do something with a thing
 */
export declare function forEach<T>(ts: Iterable<T>, act: (t: T) => void): void;
/** Data-last version of {@link forEach} */
export declare const forEach_: <T>(p: (t: T) => void) => (t: Iterable<T>) => void;
/**
 * Returns individual elements of each sub-array also works with generators.
 * @param tts nested list of things
 * @yields each individual thing
 */
export declare function flatten<ITs extends Iterable<any>[]>(...tts: ITs): Generator<UnionI<ITs>, void, undefined>;
type UnionI<ITs> = ITs extends [Iterable<infer T>, ...infer UTs] ? T | UnionI<UTs> : ITs extends [Iterable<infer T>] ? T : never;
/**
 * Calls a defined callback function on each element of a list then returns individual elements also works with generators.
 * @param ts list of things
 * @param map function to convert a thing to a list of something else
 * @yields each individual mapped thing
 */
export declare function flatMap<T, U>(ts: Iterable<T>, map: (t: T) => Iterable<U>): Generator<U, void, undefined>;
/** Data-last version of {@link flatMap} */
export declare const flatMap_: <T, U>(p: (t: T) => Iterable<U>) => (t: Iterable<T>) => Generator<U, void, undefined>;
/** Empty generator */
export declare function none<T>(): Generator<T>;
/**
 * Returns the elements of an array that meet the condition specified in a callback function.
 * ```ts
 * ts.filter(pred)
 * ```
 * But also works with generators.
 * @param ts list of things
 * @param pred function to check if thing is valid
 * @yields each valid thing
 */
export declare function filter<T>(ts: Iterable<T>, pred: (t: T) => boolean): IterableIterator<T>;
/** Data-last version of {@link filter} */
export declare const filter_: <T>(p: (t: T) => boolean) => (t: Iterable<T>) => IterableIterator<T>;
/**
 * Returns the elements of an array that meet the condition specified in a callback function.
 * ```ts
 * ts.filter(pred)
 * ```
 * But also works with generators.
 * @param ts list of things
 * @param pred function to check if thing is valid
 * @yields each valid thing
 */
export declare function filterIs<T, U extends T>(ts: Iterable<T>, pred: (t: T) => t is U): IterableIterator<U>;
/** Data-last version of {@link filterIs} */
export declare const filterIs_: <T, U extends T>(p: (t: T) => t is U) => (t: Iterable<T>) => IterableIterator<U>;
/**
 * Returns the first thing which is valid.
 * @param ts list of things
 * @param pred function to check if a thing is valid
 * @returns a thing or undefined if none are valid
 */
export declare function first<T>(ts: Iterable<T>, pred?: (t: T) => boolean): T | undefined;
/** Data-last version of {@link first} */
export declare const first_: <T>(p: ((t: T) => boolean) | undefined) => (t: Iterable<T>) => T | undefined;
/**
 * Returns if any of the thing is valid.
 * @param ts list of things
 * @param pred function to check if a thing is valid
 * @returns if any is valid
 */
export declare function some<T>(ts: Iterable<T>, pred?: (t: T) => boolean): boolean;
/**
 * Returns if all the things are valid.
 * @param ts list of things
 * @param pred function to check if a thing is valid
 * @returns if all are valid
 */
export declare function every<T>(ts: Iterable<T>, pred?: (t: T) => boolean): boolean;
/**
 * Returns the first thing which is valid.
 * @param ts list of things
 * @param pred function to check if a thing is valid
 * @returns a thing or undefined if none are valid
 */
export declare function firstIs<T, U extends T>(ts: Iterable<T>, pred: (t: T) => t is U): U | undefined;
/** Data-last version of {@link firstIs} */
export declare const firstIs_: <T, U extends T>(p: (t: T) => t is U) => (t: Iterable<T>) => U | undefined;
export declare const collect: {
    <T>(arrayLike: ArrayLike<T>): T[];
    <T_1, U>(arrayLike: ArrayLike<T_1>, mapfn: (v: T_1, k: number) => U, thisArg?: any): U[];
    <T_2>(iterable: Iterable<T_2> | ArrayLike<T_2>): T_2[];
    <T_3, U_1>(iterable: Iterable<T_3> | ArrayLike<T_3>, mapfn: (v: T_3, k: number) => U_1, thisArg?: any): U_1[];
};
/**
 * Filter an array without allocating a new one.
 * @param ts an array of things
 * @param pred function to check if a thing is valid
 * @returns same array with only valid things
 */
export declare function filterInPlace<T>(ts: T[], pred: (t: T) => boolean): T[];
/** Data-last version of {@link filterInPlace} */
export declare const filterInPlace_: <T>(p: (t: T) => boolean) => (t: T[]) => T[];
/**
 * Create a map aka dictionary from a list.
 * @param ts list of things
 * @param key function to get the key from a thing
 * @returns a map of keys and arrays of values
 */
export declare function groupBy<T, K>(ts: Iterable<T>, key: (t: T) => K): Map<K, T[]>;
/** Data-last version of {@link groupBy} */
export declare const groupBy_: <T, K>(p: (t: T) => K) => (t: Iterable<T>) => Map<K, T[]>;
/**
 * Select a random element in an array with uniform distribution.
 * @param ts an array of elements
 * @returns an element or undefined if array is empty
 */
export declare function randomPick<T>(ts: readonly T[]): T | undefined;
/**
 * Select a random element in an array with a custom distribution.
 * @param ts an array of elements
 * @param weight function returning the relative probability of each element
 * @returns an element or undefined if array is empty
 */
export declare function weightedRandomPick<T>(ts: readonly T[], weight: (t: T) => number): T | undefined;
/** Data-last version of {@link weightedRandomPick} */
export declare const weightedRandomPick_: <T>(p: (t: T) => number) => (t: readonly T[]) => T | undefined;
/**
 * Sorts an array in place by score ascending.
 * @param ts an array of things
 * @param score function to convert a thing to it's score
 * @returns the sorted array
 */
export declare function sort<T>(ts: T[], score: (t: T) => number): T[];
/** Data-last version of {@link sort} */
export declare const sort_: <T>(p: (t: T) => number) => (t: T[]) => T[];
export declare function pipe<A, B>(v: A, f1: (v: A) => B): B;
export declare function pipe<A, B, C>(v: A, f1: (v: A) => B, f2: (v: B) => C): C;
export declare function pipe<A, B, C, D>(v: A, f1: (v: A) => B, f2: (v: B) => C, f3: (v: C) => D): D;
export declare function pipe<A, B, C, D, E>(v: A, f1: (v: A) => B, f2: (v: B) => C, f3: (v: C) => D, f4: (v: D) => E): E;
export declare function pipe<A, B, C, D, E, F>(v: A, f1: (v: A) => B, f2: (v: B) => C, f3: (v: C) => D, f4: (v: D) => E, f5: (v: E) => F): F;
export declare function pipe<A, B, C, D, E, F, G>(v: A, f1: (v: A) => B, f2: (v: B) => C, f3: (v: C) => D, f4: (v: D) => E, f5: (v: E) => F, f6: (v: F) => G): G;
export declare function pipe<A, B, C, D, E, F, G, H>(v: A, f1: (v: A) => B, f2: (v: B) => C, f3: (v: C) => D, f4: (v: D) => E, f5: (v: E) => F, f6: (v: F) => G, f7: (v: G) => H): H;
/**
 * Convert data-first function to data-last.
 * @param fn a data-first function
 * @returns a data-last function
 * @example
 * const powE = partial(Math.pow)(Math.E)
 * powE(42) === Math.pow(42, Math.E)
 */
export declare function partial<T, Ps extends any[], U>(fn: (t: T, ...ps: Ps) => U): (...ps: Ps) => (t: T) => U;
/**
 * Reorder an array in place. Uses the Fisher-Yates shuffle algorithm.
 * @param ts an array of things
 * @returns the shuffled array
 */
export declare function shuffle<T>(ts: T[]): T[];
export {};
