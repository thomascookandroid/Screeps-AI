/**
 * Like `return map[key] ??= fallback(key)` but for {@link Map}.
 * @param map the target map
 * @param key element key
 * @param fallback default element value
 * @returns existing value or fallback
 */
export declare function getOrSetMap<K, V>(map: Map<K, V>, key: K, fallback: (key: K) => V): V;
/**
 * Like `key => map[key] || fallback()` but for {@link Map}.
 * @param map the target map
 * @param fallback value if missing in the map
 * @returns a getter into the map
 */
export declare function getMapWithDefault<K, V>(map: Map<K, V>, fallback: () => V): (key: K) => V;
export type Dict<K extends string, V> = Partial<Record<K, V>>;
/**
 * Create a new {@link Dict}
 * @returns an empty dict
 */
export declare function newDict<K extends string, V>(): Partial<Record<K, V>>;
/**
 * Iterate over {@link Dict} entries
 * @param d target dict
 * @returns array of key value pairs
 */
export declare function iterDict<K extends string, V>(d: Dict<K, V>): readonly [K, V][];
/**
 * Like `d[k] = v` but delete the key if {@link v} is undefined.
 * @param d target dict
 * @param k key to set
 * @param v value to set
 * @returns the value
 */
export declare function setOrDelete<K extends string, V>(d: Dict<K, V>, k: K, v: V): V;
