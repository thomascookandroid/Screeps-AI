/**
 * Check if {@link o} is real or just cached.
 * @param o object to check
 * @returns whether the object is cached or not
 */
export function isCachedObject(o) {
    return o.room === undefined;
}
/**
 * Try to get real {@link RoomObject} from cached one.
 * @param o object to restore
 * @returns real {@link RoomObject} or null
 */
export function restoreCachedObject(o) {
    return Game.getObjectById(o.id);
}
/**
 * Like {@link Room.find} with {@link CachedObject}
 * @param type kind of find query
 * @param defaultOpts optional parameters
 * @returns an array of {@link CachedObject}
 */
export function findCached(type, defaultOpts) {
    var _a;
    const cache = new Map();
    const map = ((_a = defaultOpts.map) !== null && _a !== void 0 ? _a : (({ id, pos }) => ({ id, pos })));
    return (name, opts) => {
        var _a, _b, _c, _d;
        const cached = cache.get(name);
        // Return cached if fresh
        const refresh = (_b = (_a = opts === null || opts === void 0 ? void 0 : opts.refresh) !== null && _a !== void 0 ? _a : defaultOpts.refresh) !== null && _b !== void 0 ? _b : 0;
        if (cached && Game.time <= cached[0] + refresh)
            return cached[1];
        // Try to refresh
        if (name in Game.rooms) {
            const value = Game.rooms[name]
                .find(type, defaultOpts.filter ? { filter: defaultOpts.filter } : undefined)
                .map(map);
            cache.set(name, [Game.time, value]);
            return value;
        }
        // Return cached if still valid
        const ttl = (_c = opts === null || opts === void 0 ? void 0 : opts.ttl) !== null && _c !== void 0 ? _c : defaultOpts.ttl;
        if (cached && (ttl == undefined || Game.time <= cached[0] + ttl))
            return cached[1];
        // Return fallback empty array
        const fallback = (_d = opts === null || opts === void 0 ? void 0 : opts.fallback) !== null && _d !== void 0 ? _d : defaultOpts.fallback;
        if (!fallback)
            return [];
        const fallbackValue = fallback(name);
        cache.set(name, [Number.NEGATIVE_INFINITY, fallbackValue]);
        return fallbackValue;
    };
}
//# sourceMappingURL=roomObject.js.map